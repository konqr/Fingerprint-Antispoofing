# -*- coding: utf-8 -*-
"""baseline mobilenet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12-oIrPwKhfUO0gw_5ZgVlnx9YJIXB4H_
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
from skimage.io import imread, imread_collection
import skimage.transform
import glob
import keras 
from keras.models import Model
from keras.layers import GlobalAveragePooling2D
import sklearn 
import skimage
from matplotlib import pyplot as plt
#from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from keras.utils import to_categorical

import tensorflow as tf

from keras.models import Model

X = np.asarray(imread_collection(glob.glob('/content/drive/My Drive/trainGreenBit/*/Fake*/*/*.bmp')))
trainGreenBit_fake = skimage.color.gray2rgb(skimage.transform.resize(X,[X.shape[0],224,224]))
y_fake = np.zeros([len(trainGreenBit_fake),])
X = np.asarray(imread_collection(glob.glob('/content/drive/My Drive/trainGreenBit/*/Live*/*/*.bmp')))
trainGreenBit_live = skimage.color.gray2rgb(skimage.transform.resize(X,[X.shape[0],224,224]))
y_live = np.ones([len(trainGreenBit_live),])
data = np.vstack([trainGreenBit_fake,trainGreenBit_live])
y = np.concatenate([y_fake,y_live])
print("Data Loaded!")
y2 = to_categorical(y)

def unison_shuffled_copies(a, b):
    assert len(a) == len(b)
    p = np.random.permutation(len(a))
    return a[p], b[p]

data, y = unison_shuffled_copies(data,y)

model = keras.applications.mobilenet.MobileNet(input_shape=(224,224,3), alpha=1.0, depth_multiplier=1, include_top=False, weights='imagenet', input_tensor=None, pooling=None)
es = keras.callbacks.callbacks.EarlyStopping(monitor = 'val_accuracy', min_delta=-1e-05)
x=model.output
x=GlobalAveragePooling2D()(x)
x=keras.layers.Dense(512,activation='relu')(x)
x = keras.layers.Dropout(0.5)(x)
x=keras.layers.Dense(256,activation='relu')(x)
x = keras.layers.Dropout(0.5)(x)
x=keras.layers.Dense(128,activation='relu')(x)
x = keras.layers.Dropout(0.5)(x)
preds=keras.layers.Dense(1,activation='softmax')(x)
model=Model(inputs=model.input,outputs=preds)
for layer in model.layers[:70]:
    layer.trainable=False
for layer in model.layers[70:]:
    layer.trainable=True
model.compile(optimizer='Adam',loss='binary_crossentropy',metrics=['accuracy'])
print(data.shape)
model.fit(x=data, y=y, batch_size = 64, epochs = 50, verbose=1, validation_split=0.1)
model.save('/content/drive/My Drive/baseline.h5')

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import Activation, Dropout, Flatten, Dense

model = Sequential()
model.add(Conv2D(32, (3, 3), input_shape=(224,224,3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(32, (3, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())  # this converts our 3D feature maps to 1D feature vectors
model.add(Dense(64))
model.add(Activation('relu'))
model.add(Dropout(0.5))
model.add(Dense(1))
model.add(Activation('sigmoid'))

model.compile(loss='binary_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])

model.fit(x=data, y=y, batch_size = 64, epochs = 50, verbose=1, validation_split=0.1)

model = keras.models.load_model('/content/drive/My Drive/baseline.h5')

X = np.asarray(imread_collection(glob.glob('/content/drive/My Drive/testGreenBit/*/Fake*/*/*.bmp')))
trainGreenBit_fake = skimage.color.gray2rgb(skimage.transform.resize(X,[X.shape[0],224,224]))
del X
y_fake = np.zeros([len(trainGreenBit_fake),])
X = np.asarray(imread_collection(glob.glob('/content/drive/My Drive/testGreenBit/*/Live*/*/*.bmp')))
trainGreenBit_live = skimage.color.gray2rgb(skimage.transform.resize(X,[X.shape[0],224,224]))
del X
y_live = np.ones([len(trainGreenBit_live),])
data = np.vstack([trainGreenBit_fake,trainGreenBit_live])
del trainGreenBit_fake
del trainGreenBit_live
y = np.concatenate([y_fake,y_live])
print("Data Loaded!")

temp = skimage.transform.resize(X[0],[224,224])
for i in range(1,len(X)):
  r = skimage.transform.resize(X[i],[224,224])
  temp = np.vstack([temp,r])

temp2 = np.reshape(temp,[1702,224,224])

trainGreenBit_live = skimage.color.gray2rgb(temp2)
del X
y_live = np.ones([len(trainGreenBit_live),])
data = np.vstack([trainGreenBit_fake,trainGreenBit_live])
del trainGreenBit_fake
del trainGreenBit_live
y = np.concatenate([y_fake,y_live])
print("Data Loaded!")

import gc
gc.collect()

results = model.evaluate(data, y, batch_size=128)
print('test loss, test acc:', results)

img = np.uint8(np.random.uniform(100, 200, (224, 224, 3)))/255
filters, biases = model.layers[0].get_weights()
# normalize filter values to 0-1 so we can visualize them
f_min, f_max = filters.min(), filters.max()
filters = (filters - f_min) / (f_max - f_min)
# plot first few filters
n_filters, ix = 10, 1
for i in range(n_filters):
	# get the filter
	f = filters[:, :, :, i]
	# plot each channel separately
	for j in range(3):
		# specify subplot and turn of axis
		ax = plt.subplot(n_filters, 3, ix)
		ax.set_xticks([])
		ax.set_yticks([])
		# plot filter channel in grayscale
		plt.imshow(f[:, :, j], cmap='gray')
		ix += 1
# show the figure
plt.show()

#arr = glob.glob('/content/drive/My Drive/trainGreenBit/*/Fake*/*/*.bmp')
img = imread('/content/drive/My Drive/testGreenBit/017_21_0/Fake/Liquid_Ecoflex_01/FLAT_INDEX_RIGHT.bmp')
img = skimage.transform.resize(img,[224,224])
img = skimage.color.gray2rgb(img)
img = img.reshape(1,224,224,3)

model2 = Model(inputs=model.inputs, outputs=model.layers[7].output)
feature_maps = model2.predict(img)

square = 8
ix = 1
plt.figure(num=None, figsize=(20, 10), dpi=80, facecolor='w', edgecolor='k')
for _ in range(square):
	for _ in range(4):
		# specify subplot and turn of axis
		ax = plt.subplot(square, 4, ix)
		ax.set_xticks([])
		ax.set_yticks([])
		# plot filter channel in grayscale
		plt.imshow(feature_maps[0, :, :, ix-1], cmap='gray')
		ix += 1
# show the figure
plt.show()

